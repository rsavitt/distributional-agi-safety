# Kernel Market Baseline Scenario
# Multi-agent GPU kernel marketplace where agents produce, verify, and trade
# CUDA/Triton kernels sourced from LeetGPU challenge specs.
#
# Proxy signal mapping (LeetGPU → SWARM observables):
#   task_progress_delta  ← fraction of functional tests passed (0→1)
#   rework_count         ← compilation failures before success
#   verifier_rejections  ← test failures found by verifier agent
#   tool_misuse_flags    ← precision hacks detected (hardcoded values, tolerance exploits)
#   engagement_delta     ← performance improvement over reference (normalized)
#
# Adverse selection story:
#   Buyer (orchestrator) sees proxy signals: unit test pass rate + perf sample.
#   Adversarial agents produce "too-good-to-be-true" kernels that exploit proxy gaps:
#     - Pass functional tests but fail on out-of-distribution inputs
#     - Show high speedup by cutting numerical precision corners
#     - Overfit to test distribution (hardcoded edge cases)
#   Governance levers (audits, staking, circuit breakers) should reduce cheat incidence
#   without killing throughput from honest authors.
#
# LeetGPU integration (external dependency, not bundled):
#   Challenges consumed via AlphaGPU/leetgpu-challenges repo structure:
#     challenges/{difficulty}/{id}_{name}/challenge.py  → oracle (tests + reference)
#     challenges/{difficulty}/{id}_{name}/challenge.html → spec for agents
#     challenges/{difficulty}/{id}_{name}/starter/       → templates
#   License: CC BY-NC-ND 4.0 — reference as external dep, do not redistribute.

scenario_id: kernel_market_baseline
description: >
  GPU kernel marketplace with honest authors, opportunistic speed-chasers,
  adversarial benchmark gamers, and independent verifiers. Tests whether
  market-level proxy signals select for correct+fast kernels or get gamed.
motif: kernel_market

simulation:
  n_epochs: 20
  steps_per_epoch: 10
  seed: 42

# Marketplace: challenges posted as bounties, kernels submitted as bids
marketplace:
  enabled: true
  escrow_fee_rate: 0.03
  min_bounty_amount: 2.0
  max_bids_per_bounty: 8
  bid_deadline_epochs: 2
  dispute_resolution_epochs: 1
  auto_expire_bounties: true
  dispute_default_split: 0.5

# Payoff: high surplus for correct+fast, high harm for wrong kernels downstream
payoff:
  s_plus: 3.0       # Correct + performant kernel has high value
  s_minus: 2.0      # Wrong kernel causes production failures
  h: 4.0            # Downstream harm from bad kernels (silent numerical errors)
  theta: 0.5        # Even surplus split between author and consumer
  rho_a: 0.1        # Authors bear some externality cost
  rho_b: 0.1        # Consumers bear some externality cost
  w_rep: 1.5        # Reputation weight — quality track record matters

# Governance: moderate baseline
governance:
  # Audit: random deep testing beyond surface-level functional tests
  audit_enabled: true
  audit_probability: 0.15
  audit_penalty_multiplier: 3.0
  audit_threshold_p: 0.5

  # Staking: authors stake reputation on kernel correctness
  staking_enabled: true
  min_stake_to_participate: 0.5
  stake_slash_rate: 0.2

  # Circuit breaker: freeze agents producing consistently bad kernels
  circuit_breaker_enabled: true
  freeze_threshold_toxicity: 0.6
  freeze_threshold_violations: 2
  freeze_duration_epochs: 3

  # Reputation decays — past quality doesn't excuse current failures
  reputation_decay_rate: 0.95

  # Bandwidth: limit kernel submissions per epoch (prevents flood attacks)
  bandwidth_cap: 5

  # Transaction tax on kernel trades
  transaction_tax_rate: 0.05
  transaction_tax_split: 0.5

# Kernel oracle: simulates kernel quality outcomes
kernel_oracle:
  enabled: true
  seed: 42
  difficulty_distribution:
    easy: 0.4
    medium: 0.4
    hard: 0.2
  honest_quality_mean: 0.85
  opportunistic_quality_mean: 0.55
  adversarial_quality_mean: 0.75
  adversarial_cheat_rate: 0.6
  audit_detection_rate: 0.8
  verifier_detection_rate: 0.3

# Agents
agents:
  # Honest kernel authors: prioritize correctness, reasonable performance
  - type: honest
    count: 3
    name: kernel_author
    role: kernel_author
    config:
      quality_mean: 0.8
      speed_priority: 0.3

  # Opportunistic authors: chase speed benchmarks, cut correctness corners
  # (pass tests but use looser tolerances, skip edge cases)
  - type: opportunistic
    count: 2
    name: fast_author
    role: kernel_author
    config:
      quality_mean: 0.45
      speed_priority: 0.9

  # Verifiers: run tests, check numerics, report results
  - type: verifier
    count: 2
    name: kernel_verifier
    role: verifier
    config:
      accuracy: 0.8

  # Adversarial benchmark gamers: exploit proxy signals
  # (overfit to test distribution, precision hacks, hardcoded edge cases)
  - type: adversarial
    count: 1
    name: benchmark_gamer
    role: kernel_author
    config:
      exploit_proxy: true
      target_signal: performance

rate_limits:
  posts_per_epoch: 5         # Kernel submissions per agent
  interactions_per_step: 3
  votes_per_epoch: 20
  tasks_per_epoch: 5
  bounties_per_epoch: 3
  bids_per_epoch: 5

# Success criteria
success_criteria:
  min_epochs: 10
  min_agents: 5
  toxicity_threshold: 0.3    # Max 30% bad kernels accepted
  quality_gap_min: 0.05      # Must select better kernels than random

# Outputs
outputs:
  event_log: runs/kernel_market/baseline/events.jsonl
  metrics_csv: runs/kernel_market/baseline/metrics.csv
  plots_dir: runs/kernel_market/baseline/plots
